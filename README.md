# Data Visualization

An [Omeka S](https://omeka.org/s/) module for visualizing your data.

# Important Info

For loading and configuring any module, Laminas provides a **ModuleManager**. This ModuleManager looks for Module class in the module namespace (Datavis in our case). For this case, ModuleManager will need a class Datavis/Module. This class is defined inside the **Module.php** file. Inside this class, the ModuleManager looks for **getConfig()** method and calls it automatically. So, it seems the getConfig() is the starting method for us to look into.

Next, the getConfig() method loads a file **config/module.config.php**.

Next, the config information provided in the **config/module.config.php** file is passed to the relevant components by the **ServiceManager**. Thus, if we look inside this file, we have sections for various components. For example, **controllers** and **view_manager**. The **controller** section provides the list of all the controllers provided by the module. The controller can be referenced fully by qualified class name, and the laminas-servicemanager **InvokableFactory** can be used to create instances of it.

Next, let's discuss **view_manager** section. In this section, the view directory is added to the **TemplatePathStack** configuration. This allows it to find the view scripts for the Module stored inside the view/ directory.

With this wee next move to the main application's (not included here, but it is in the Omeka S) config/modules.config.php file. In this file, we need to add the module (Datavis) so that the application knows of its existence.

Next, let's understand organization of the pages that the Laminas expects. Remeber, each page of the application is known as an **action**. Actions are then grouped into **controllers** within modules. Therefore, related actions are generally grouped into one controller. Based on the requirement of your application, plan about the pages (actions) that could exist, and based on their relationsips, organize them into various or single controller(s). In the case of Datavis, for admin and general, there are two separate folders and each contains a single controller.

Next, understanding the **routes**. The routes help in mapping of a URL to a particular action. The routes are also defined in the **module.config.php** file. For example, lets say we have a homepage (action) index, this becomes one of the member of the routes array inside the router array in the config file. The index action has various array properties (keys). Eg. 'type' defines its route type, and we could use Segment::class for it. The segment route allows for specifying placeholders in the URL pattern (route) that will be mapped to named parameters in the matched route. So, inside the 'options' key for the action, we can define 'route' key to be 'index/[/:action[/:id]]'. Remember here, index is our action. With this definition of 'route' key, it matches any URL starting with '/index'. Also, we have placed action and id inside the square bracket, meaning these are optional for our actions. Also, inside the 'options' key, we can define 'constraints' for these actions which could be used with the 'action' key which can be used to define the possible names for the actions inside the /index page. And, also 'id' key, which can be used to give the ids of the items that the action inside the index action can work on. Using regex, we can limit the actions to be only alphanumeric, and ids to be numeric.

Next, we look into building a controller. We define files inside Controller folder to define each controller. The files are named such that for example, IndexController.php refers to the controller by name 'Index'. The name of the controller must start with capital letter. We define a Controller class (IndexController) in this file which extends from AbstactActionController class. Now, every action is defined as a public method within the Controller class. For example, the index action is named indexAction(), and it starts with lower case letter. Thus, after creating the methods inside the controller(s), on navigating to the correct URL, the respective method will be called.

Once Controllers are set up with actions, our next targets should be to setup the views and the models. The views are integrated to the application by creating view scripts, and these scripts will be executed by the **defaultViewStrategy**. Remember here that any variables or view models that were returned from the controller action method will be passed to the view during the execution of the strategy. The view files are defined as .phtml files inside the view/<smalle lettered modulename>/<small lettered controller name>.

Next let's understand the models. The model is the **core** part of any application, meaning the business of the application is the model. Therefore, it is the one that generally deals with the **database**. Generally the sql schema definition along with data insertion for testing can be placed inside the data folder. The model files can be organized based on the application's need. A general approach is to have model classes represent each entity in the application and then use mapper objects that load and save entities to the database. To understand entities, we can think of them as the objects that make up the application. For example, if our application is about music albums, singer could be entities, albums could be entities, customers could be entities. These are generally the real-world objects that make up the logic of our application. Similarly, we could also use ORM (Object-Relational Mapping) like doctrine to do the mapping for us to save the entities to the database.
Inside the entity class definition, an **exchangeArray()** method can be used to copy the data from the array provided as an argument to the properties of the entity ($this->id = array['id']), for example. An input filter can be added to the function definition to ensure the values are valid. Remember we are creating the entity class in the namespace Module/Model.

Let's now understand the basic mechanism using laminas-db's Laminas/Db/TableGateway/TableGateway subcomponent for database operations inside the model. Simply put TableGateway subcomponent is an OOP representation of any database table. TableGateway Interface has basically two implementations, AbstractTableGateway and TableGateway. AbstractTableGateway provides basic implementations for CRUD (create(), etc.), along with an API for operating in Laminas/Db/Sql objects, insertWith(), etc. At the same time it can be used to extend the TableGateway without working with TableGateway directly. We can create a separate class, for example, DataVisTable to work with the database operations. This class consumes a **Laminas/Db/TableGateway/TableGateway** subcomponent. The **exchangeArray()** method is required to work with the TableGateway. Inside the DataVisTable class, we use the constructor to set the tableGateway property of the class to be equal to the TableGatewayInterface object that is passed as an argument to the constructor. Then we define various methods required for the database operations.

Next, we look into using ServiceManager to configure the table gateway and inject into the DataVisTable. Since we need to always operate on the same instance of the DataVisTable class, we need to use **serviceManager** to create such an instance. This is done in the Module class by defining a method 'getServiceConfig()'.

Understanding Factories is important, as it becomes useful for both Model and also Controller. Factory method are an abstract way of defining constructor, meaning we leave the implementation of the constructor to the subclasses that inherit from the class. In other words, if a class is an abstract class that will not have any objects, but its subclasses will have the instances, in such case we use factory method.

**A lot of complicated items here... we won't look into details for now!**

Okay, let's say we have now defined Model somehow. Next step would be to pass the Model to the controller so that we can start using it. First, a constructor is added to the Controller, which takes DataVisTable object as an argument. We then assign it to the property of the Controller class. Also, since the Controller depends on the DatavisTable class, we need to create a factory for the controller, why??

Now, working with the database, lets say we want to list the albums. For this, we need to retrieve them from Model and pass them to view. For this, we fill in indexAction() within AlbumController. Remember this, in order to set variables in the view, we return a ViewModel instance where the first parameter of the constructor is an array containing data we wish to represent. These are then automatically passed to the view script. The ViewModel object also allows to change the view script that is used, but the default is to use {module name}/{controller name}/{action name}. Next we fill in the index.phtml view script. Here's something we do with the phtml view file:
-use headTitle() to provide the title for the page.
-use url() view helper to create the links we need.. The first parameter is the route name we wish to use for construction of the url, second parameter is an array of variables to substitute into rout placeholdres.
-use escapeHtml() helper to hep protect from croll site scripting (XSS).

## Extra Info not related to module but to the main Omeaka-S:

Although Laminas does have autoloading capabilities, the recommended method is to use composer's autoloading. So, the namespae has to be informed to the composer, along with the information on where the namespace's file exist. This is done in composer.json file in the project root inside autoload section.
